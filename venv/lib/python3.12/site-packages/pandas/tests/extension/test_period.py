"""

parent method).

classes (if they are relevant for the extension interface for all dtypes), or

"""
from __future__ import annotations

from typing import TYPE_CHECKING

import numpy as np

from pandas._libs import (
    Period,
    iNaT,
)
from pandas.compat import is_platform_windows
from pandas.compat.numpy import np_version_gte1p24

from pandas.core.dtypes.dtypes import PeriodDtype

from pandas.core.arrays import PeriodArray

if TYPE_CHECKING:
    import pandas as pd


def dtype(request):
    return PeriodDtype(freq=request.param)


def data(dtype):
    return PeriodArray(np.arange(1970, 2070), dtype=dtype)


def data_for_sorting(dtype):
    return PeriodArray([2018, 2019, 2017], dtype=dtype)


def data_missing(dtype):
    return PeriodArray([iNaT, 2017], dtype=dtype)


def data_missing_for_sorting(dtype):
    return PeriodArray([2018, iNaT, 2017], dtype=dtype)


def data_for_grouping(dtype):
    B = 2018
    NA = iNaT
    A = 2017
    C = 2019
    return PeriodArray([B, B, NA, NA, A, A, B, C], dtype=dtype)


class TestPeriodArray(base.ExtensionTests):
    def _get_expected_exception(self, op_name, obj, other):
        if op_name in ("__sub__", "__rsub__"):
            return None
        return super()._get_expected_exception(op_name, obj, other)

    def _supports_accumulation(self, ser, op_name: str) -> bool:
        return op_name in ["cummin", "cummax"]

    def _supports_reduction(self, obj, op_name: str) -> bool:
        return op_name in ["min", "max", "median"]

    def check_reduce(self, ser: pd.Series, op_name: str, skipna: bool):
        if op_name == "median":
            res_op = getattr(ser, op_name)

            alt = ser.astype("int64")

            exp_op = getattr(alt, op_name)
            result = res_op(skipna=skipna)
            expected = exp_op(skipna=skipna)
            # error: Item "dtype[Any]" of "dtype[Any] | ExtensionDtype" has no
            # attribute "freq"
            freq = ser.dtype.freq  # type: ignore[union-attr]
            expected = Period._from_ordinal(int(expected), freq=freq)
            tm.assert_almost_equal(result, expected)

        else:
            return super().check_reduce(ser, op_name, skipna)

        if is_platform_windows() and np_version_gte1p24:
            with tm.assert_produces_warning(RuntimeWarning, check_stacklevel=False):
        else:

        result = data.map(lambda x: x, na_action=na_action)
        tm.assert_extension_array_equal(result, data)


class Test2DCompat(base.NDArrayBacked2DTests):
    pass
