# Tests specifically aimed at detecting bad arguments.
# This file is organized by reason for exception.
#     1. always invalid argument values
#     2. missing column(s)
#     3. incompatible ops/dtype/args/kwargs
#     4. invalid result shape/type

from itertools import chain
import re

import numpy as np

from pandas.errors import SpecificationError

from pandas import (
    DataFrame,
    Series,
    date_range,
)


    # allowed result_type
    df = DataFrame(
        np.tile(np.arange(3, dtype="int64"), 6).reshape(6, -1) + 1,
        columns=["A", "B", "C"],
    )

    msg = (
        "invalid value for result_type, must be one of "
        "{None, 'reduce', 'broadcast', 'expand'}"
    )
        df.apply(lambda x: [1, 2, 3], axis=1, result_type=result_type)


    df = DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], index=["a", "a", "c"])
    msg = "No axis named 2 for object type DataFrame"
        df.apply(lambda x: x, 2)


    # GH 26513
    df = DataFrame({"A": [0, 1], "B": [1, 2]})
    msg = "Must provide"

        df.agg()


    # https://github.com/pandas-dev/pandas/issues/32815
    s = Series([1, 2, 3])
    msg = "na_action must either be 'ignore' or None"
        s.map(lambda x: x, na_action="____")


    # https://github.com/pandas-dev/pandas/issues/46588
    s = Series([1, 2, 3])
    msg = f"na_action must either be 'ignore' or None, {input_na_action} was passed"
        s.map({1: 2}, na_action=input_na_action)


    # GH 35964
    obj = frame_or_series({"A": [1]})
    match = "nested renamer is not supported"
        getattr(obj, method)(func)


    "renamer",
    [{"foo": ["min", "max"]}, {"foo": ["min", "max"], "bar": ["sum", "mean"]}],
)
    s = Series(range(6), dtype="int64", name="series")
    msg = "nested renamer is not supported"
        s.agg(renamer)


    tsdf = DataFrame(
        np.random.default_rng(2).standard_normal((10, 3)),
        columns=["A", "B", "C"],
        index=date_range("1/1/2000", periods=10),
    )
    msg = "nested renamer is not supported"
        tsdf.A.agg({"foo": ["sum", "mean"]})


    df = DataFrame({"A": range(5), "B": 5})

    # nested renaming
    msg = r"nested renamer is not supported"
        getattr(df, method)({"A": {"foo": "min"}, "B": {"bar": "max"}})


    # GH 40004
    obj = DataFrame({"A": [1]})
    match = re.escape("Column(s) ['B'] do not exist")
        getattr(obj, method)(func)


    # GH39025
    df = DataFrame({"a": ["1"]})
    msg = r"Column\(s\) \[1, 'b'\] do not exist"
        df.transform({"a": int, 1: str, "b": int})


    "how, args", [("pct_change", ()), ("nsmallest", (1, ["a", "b"])), ("tail", 1)]
)
    # GH 39211 - some ops don't support axis=1
    df = DataFrame({"a": [1, 2], "b": [3, 4]})
    msg = f"Operation {how} does not support axis=1"
        df.apply(how, axis=1, args=args)


    # GH 35964
    msg = "No axis named 1 for object type Series"
        Series([1]).transform("sum", axis=1)


    data = DataFrame(
        {
            "A": [
                "foo",
                "foo",
                "foo",
                "foo",
                "bar",
                "bar",
                "bar",
                "bar",
                "foo",
                "foo",
                "foo",
            ],
            "B": [
                "one",
                "one",
                "one",
                "two",
                "one",
                "one",
                "one",
                "two",
                "two",
                "two",
                "one",
            ],
            "C": [
                "dull",
                "dull",
                "shiny",
                "dull",
                "dull",
                "shiny",
                "shiny",
                "dull",
                "shiny",
                "shiny",
                "shiny",
            ],
            "D": np.random.default_rng(2).standard_normal(11),
            "E": np.random.default_rng(2).standard_normal(11),
            "F": np.random.default_rng(2).standard_normal(11),
        }
    )

    data.loc[4, "C"] = np.nan

    def transform(row):
        if row["C"].startswith("shin") and row["A"] == "foo":
            row["D"] = 7
        return row

    msg = "'float' object has no attribute 'startswith'"
        data.apply(transform, axis=1)


    "df, func, expected",
    tm.get_cython_table_params(
        DataFrame([["a", "b"], ["b", "a"]]), [["cumprod", TypeError]]
    ),
)
    # GH 21224
    if using_infer_string:
        expected = (expected, NotImplementedError)

    msg = (
        "can't multiply sequence by non-int of type 'str'"
        "|cannot perform cumprod with type str"  # NotImplementedError python backend
        "|operation 'cumprod' not supported for dtype 'str'"  # TypeError pyarrow
    )
    warn = None if isinstance(func, str) else FutureWarning
        with tm.assert_produces_warning(warn, match="using DataFrame.cumprod"):
            df.agg(func, axis=axis)


    "series, func, expected",
    chain(
        tm.get_cython_table_params(
            Series("a b c".split()),
            [
                ("mean", TypeError),  # mean raises TypeError
                ("prod", TypeError),
                ("std", TypeError),
                ("var", TypeError),
                ("median", TypeError),
                ("cumprod", TypeError),
            ],
        )
    ),
)
    # GH21224
    msg = r"[Cc]ould not convert|can't multiply sequence by non-int of type"
    if func == "median" or func is np.nanmedian or func is np.median:
        msg = r"Cannot convert \['a' 'b' 'c'\] to numeric"

    if using_infer_string and func in ("cumprod", np.cumprod, np.nancumprod):
        expected = (expected, NotImplementedError)

    msg = (
        msg + "|does not support|has no kernel|Cannot perform|cannot perform|operation"
    )
    warn = None if isinstance(func, str) else FutureWarning

        # e.g. Series('a b'.split()).cumprod() will raise
        with tm.assert_produces_warning(warn, match="is currently using Series.*"):
            series.agg(func)


    # GH 40543
    df = DataFrame({"a": [None]})
    msg = re.escape("int() argument must be a string")
        df.agg({"a": lambda x: int(x.iloc[0])})


    # GH#34377
    df = DataFrame({"a": [None]})
    msg = "argument must be a"
        df.transform({"a": lambda x: int(x.iloc[0])})


    "func",
    [
        lambda x: np.array([1, 2]).reshape(-1, 2),
        lambda x: [1, 2],
        lambda x: Series([1, 2]),
    ],
)
    df = DataFrame(
        np.tile(np.arange(3, dtype="int64"), 6).reshape(6, -1) + 1,
        columns=["A", "B", "C"],
    )

    # > 1 ndim
    msg = "too many dims to broadcast|cannot broadcast result"
        df.apply(func, axis=1, result_type="broadcast")


    # cannot both transform and agg
    msg = "cannot combine transform and aggregation operations"
        with np.errstate(all="ignore"):
            float_frame.agg(["max", "sqrt"], axis=axis)


    "func, msg",
    [
        (["sqrt", "max"], "cannot combine transform and aggregation"),
        (
            {"foo": np.sqrt, "bar": "sum"},
            "cannot perform both aggregation and transformation",
        ),
    ],
)
    # we are trying to transform with an aggregator
        with np.errstate(all="ignore"):
            string_series.agg(func)


    # GH 35964
    # cannot both transform and agg
    msg = "Function did not transform"
        float_frame.transform(func, axis=axis)


    # GH 35964
    # we are trying to transform with an aggregator
    msg = "Function did not transform"

        string_series.transform(func)


    "op_wrapper", [lambda x: x, lambda x: [x], lambda x: {"A": x}, lambda x: {"A": [x]}]
)
    # GH 35964
    op = op_wrapper(all_reductions)

    obj = DataFrame({"A": [1, 2, 3]})
    obj = tm.get_obj(obj, frame_or_series)

    msg = "Function did not transform"
        obj.transform(op)
