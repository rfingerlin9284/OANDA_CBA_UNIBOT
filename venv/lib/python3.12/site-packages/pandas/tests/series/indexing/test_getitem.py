"""
"""
from datetime import (
    date,
    datetime,
    time,
)

import numpy as np

from pandas._libs.tslibs import (
    conversion,
    timezones,
)

from pandas.core.dtypes.common import is_scalar

import pandas as pd
from pandas import (
    Categorical,
    DataFrame,
    DatetimeIndex,
    Index,
    Series,
    Timestamp,
    date_range,
    period_range,
    timedelta_range,
)
from pandas.core.indexing import IndexingError

from pandas.tseries.offsets import BDay


class TestSeriesGetitemScalars:
        # GH#17286
        ser = Series([1] * 4, index=Index(["a", "b", "c", 1.0]))
        assert ser["a"] == 1
        assert ser[1.0] == 1

        # see GH#13509

        # unique Index
        ser = Series([(1, 1), (2, 2), (3, 3)], index=[0.0, 0.1, 0.2], name="foo")
        result = ser[0.0]
        assert result == (1, 1)

        # non-unique Index
        expected = Series([(1, 1), (2, 2)], index=[0.0, 0.0], name="foo")
        ser = Series([(1, 1), (2, 2), (3, 3)], index=[0.0, 0.0, 0.2], name="foo")

        result = ser[0.0]
        tm.assert_series_equal(result, expected)

        # GH#32684 a scalar key that is not recognized by lib.is_scalar

        # a series that might be produced via `frame.dtypes`
        ser = Series([1, 2], index=[np.dtype("O"), np.dtype("i8")])

        key = ser.index[1]

        result = ser[key]
        assert result == 2

        ser = Series(["a"] * 10, index=["a"] * 10)

        msg = "index -11 is out of bounds for axis 0 with size 10|index out of bounds"
        warn_msg = "Series.__getitem__ treating keys as positions is deprecated"
            with tm.assert_produces_warning(FutureWarning, match=warn_msg):
                ser[-11]

        # don't segfault, GH#495
        msg = r"index \d+ is out of bounds for axis 0 with size \d+"
        warn_msg = "Series.__getitem__ treating keys as positions is deprecated"
            with tm.assert_produces_warning(FutureWarning, match=warn_msg):
                datetime_series[len(datetime_series)]

        # GH#917
        # With a RangeIndex, an int key gives a KeyError
        ser = Series([], dtype=object)
            ser[-1]

        dtype = any_int_numpy_dtype
        ser = Series(
            np.random.default_rng(2).standard_normal(6),
            index=Index([0, 0, 1, 1, 2, 2], dtype=dtype),
        )

            ser[5]

            ser["c"]

        # not monotonic
        ser = Series(
            np.random.default_rng(2).standard_normal(6), index=[2, 2, 0, 0, 1, 1]
        )

            ser[5]

            ser["c"]

        idx = np.int64(5)
        msg = "Series.__getitem__ treating keys as positions is deprecated"
        with tm.assert_produces_warning(FutureWarning, match=msg):
            res = datetime_series[idx]
        assert res == datetime_series.iloc[5]

        # github.com/pandas-dev/pandas/commit/4f433773141d2eb384325714a2776bcc5b2e20f7
        ser = Series(range(5), index=list(range(5)))
        result = ser[list(range(5))]
        tm.assert_series_equal(result, ser)

    # ------------------------------------------------------------------
    # Series with DatetimeIndex

        tz = timezones.maybe_get_tz(tzstr)

        index = date_range(
            start="2012-12-24 16:00", end="2012-12-24 18:00", freq="h", tz=tzstr
        )
        ts = Series(index=index, data=index.hour)
        time_pandas = Timestamp("2012-12-24 17:00", tz=tzstr)

        dt = datetime(2012, 12, 24, 17, 0)
        time_datetime = conversion.localize_pydatetime(dt, tz)
        assert ts[time_pandas] == ts[time_datetime]

        rng = date_range("1/1/2000", periods=10, tz=tz)
        ser = Series(np.random.default_rng(2).standard_normal(len(rng)), index=rng)

        result = ser["1/3/2000"]
        tm.assert_almost_equal(result, ser.iloc[2])

        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
        ts = Series(np.random.default_rng(2).standard_normal(len(rng)), index=rng)

        mask = (rng.hour == 9) & (rng.minute == 30)
        result = ts[time(9, 30)]
        expected = ts[mask]
        result.index = result.index._with_freq(None)
        tm.assert_series_equal(result, expected)

    # ------------------------------------------------------------------
    # Series with CategoricalIndex

        cats = Categorical([Timestamp("12-31-1999"), Timestamp("12-31-2000")])

        ser = Series([1, 2], index=cats)

        expected = ser.iloc[0]
        result = ser[cats[0]]
        assert result == expected

        # GH#15470
        ser = Series(["a", "b", "c"], index=pd.CategoricalIndex([2, 1, 0]))

        # 0 is treated as a label
        assert ser[0] == "c"

        # the listlike analogue should also be treated as labels
        res = ser[[0]]
        expected = ser.iloc[-1:]
        tm.assert_series_equal(res, expected)

        res2 = ser[[0, 1, 2]]
        tm.assert_series_equal(res2, ser.iloc[::-1])

        # GH#14865
        ser = Series(["a", "b", "c"], index=Index([1, 2, 3], dtype="category"))
        assert ser.get(3) == "c"
        assert ser[3] == "c"

        rng = timedelta_range("1 day 10:11:12", freq="h", periods=500)
        ser = Series(np.arange(len(rng)), index=rng)

        key = "6 days, 23:11:12"
        indexer = rng.get_loc(key)
        assert indexer == 133

        result = ser[key]
        assert result == ser.iloc[133]

        msg = r"^Timedelta\('50 days 00:00:00'\)$"
            rng.get_loc("50 days")
            ser["50 days"]

        # GH#48653
        ser = Series({True: 1, False: 0})
        msg = "Series.__getitem__ treating keys as positions is deprecated"
        with tm.assert_produces_warning(FutureWarning, match=msg):
            result = ser[0]
        assert result == 1


class TestSeriesGetitemSlices:
        # GH#34860
        arr = date_range("1/1/2008", "1/1/2009")
        ser = arr.to_series()
        result = ser["2008"]

        rng = date_range(start="2008-01-01", end="2008-12-31")
        expected = Series(rng, index=rng)

        tm.assert_series_equal(result, expected)

        idx = DatetimeIndex(
            ["1/1/2000", "1/2/2000", "1/2/2000", "1/3/2000", "1/4/2000"]
        )

        ts = Series(np.random.default_rng(2).standard_normal(len(idx)), index=idx)

        result = ts["1/2/2000":]
        expected = ts[1:]
        tm.assert_series_equal(result, expected)

        result = ts["1/2/2000":"1/3/2000"]
        expected = ts[1:4]
        tm.assert_series_equal(result, expected)

        rng = timedelta_range("1 day 10:11:12", freq="h", periods=500)
        ser = Series(np.arange(len(rng)), index=rng)

        result = ser["5 day":"6 day"]
        expected = ser.iloc[86:134]
        tm.assert_series_equal(result, expected)

        result = ser["5 day":]
        expected = ser.iloc[86:]
        tm.assert_series_equal(result, expected)

        result = ser[:"6 day"]
        expected = ser.iloc[:134]
        tm.assert_series_equal(result, expected)

        # higher reso
        rng = timedelta_range("1 day 10:11:12", freq="us", periods=2000)
        ser = Series(np.arange(len(rng)), index=rng)

        result = ser["1 day 10:11:12":]
        expected = ser.iloc[0:]
        tm.assert_series_equal(result, expected)

        result = ser["1 day 10:11:12.001":]
        expected = ser.iloc[1000:]
        tm.assert_series_equal(result, expected)

        result = ser["1 days, 10:11:12.001001"]
        assert result == ser.iloc[1001]

        # GH#30588 multi-dimensional indexing deprecated
            datetime_series[:, np.newaxis]

        index = date_range("20090415", "20090519", freq="2B")
        ser = Series(np.random.default_rng(2).standard_normal(13), index=index)

        indexer = [slice(6, 7, None)]
        msg = "Indexing with a single-item list"
            # GH#31299
            ser[indexer]
        # but we're OK with a single-element tuple
        result = ser[(indexer[0],)]
        expected = ser[indexer[0]]
        tm.assert_series_equal(result, expected)

        "slc, positions",
        [
            [slice(date(2018, 1, 1), None), [0, 1, 2]],
            [slice(date(2019, 1, 2), None), [2]],
            [slice(date(2020, 1, 1), None), []],
            [slice(None, date(2020, 1, 1)), [0, 1, 2]],
            [slice(None, date(2019, 1, 1)), [0]],
        ],
    )
        # https://github.com/pandas-dev/pandas/issues/31501
        ser = Series(
            [0, 1, 2],
            DatetimeIndex(["2019-01-01", "2019-01-01T06:00:00", "2019-01-02"]),
        )
        result = ser[slc]
        expected = ser.take(positions)
        tm.assert_series_equal(result, expected)

        msg = (
            "cannot do slice indexing on DatetimeIndex with these indexers "
            r"\[{key}\] of type float"
        )
            datetime_series[4.0:10.0]

            datetime_series[4.5:10.0]

        ser = Series(range(10), index=list(range(10)))
        result = ser[-12:]
        tm.assert_series_equal(result, ser)

        result = ser[-7:]
        tm.assert_series_equal(result, ser[3:])

        result = ser[:-12]
        tm.assert_series_equal(result, ser[:0])

        ser = Series(
            np.random.default_rng(2).standard_normal(8),
            index=[2, 4, 6, 8, 10, 12, 14, 16],
        )

        result = ser[:4]
        expected = Series(ser.values[:4], index=[2, 4, 6, 8])
        tm.assert_series_equal(result, expected)


class TestSeriesGetitemListLike:
        # GH#33462 we expect the same behavior for list/ndarray/Index/Series
        ser = Series(["A", "B"])

        key = Series(["C"])
        key = box(key)

        msg = r"None of \[Index\(\['C'\], dtype='object|str'\)\] are in the \[index\]"
            ser[key]

        ser = Series(period_range("2000-01-01", periods=10, freq="D"))

        result = ser[[2, 4]]
        exp = Series(
            [pd.Period("2000-01-03", freq="D"), pd.Period("2000-01-05", freq="D")],
            index=[2, 4],
            dtype="Period[D]",
        )
        tm.assert_series_equal(result, exp)
        assert result.dtype == "Period[D]"

        # GH#33404 fall back to positional since ints are unambiguous
        dti = date_range("2000-01-03", periods=3)._with_freq(None)
        ii = pd.IntervalIndex.from_breaks(dti)
        ser = Series(range(len(ii)), index=ii)

        expected = ser.iloc[:1]
        key = box([0])
        msg = "Series.__getitem__ treating keys as positions is deprecated"
        with tm.assert_produces_warning(FutureWarning, match=msg):
            result = ser[key]
        tm.assert_series_equal(result, expected)

        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)

        key = box([5])
            ser[key]

        # GH #37218
        ser = Series([1, 2, 3])
        key = np.array([4], dtype=any_unsigned_int_numpy_dtype)

            ser[key]
            ser.loc[key]


class TestGetitemBooleanMask:
        ser = string_series
        mask = ser > ser.median()

        # passing list is OK
        result = ser[list(mask)]
        expected = ser[mask]
        tm.assert_series_equal(result, expected)
        tm.assert_index_equal(result.index, ser.index[mask])

        ser = Series([], dtype=np.int64)
        ser.index.name = "index_name"
        ser = ser[ser.isna()]
        assert ser.index.name == "index_name"
        assert ser.dtype == np.int64

        # GH#5877
        # indexing with empty series
        ser = Series(["A", "B"], dtype=object)
        expected = Series(dtype=object, index=Index([], dtype="int64"))
        result = ser[Series([], dtype=object)]
        tm.assert_series_equal(result, expected)

        # invalid because of the boolean indexer
        # that's empty or not-aligned
        msg = (
            r"Unalignable boolean Series provided as indexer \(index of "
            r"the boolean Series and of the indexed object do not match"
        )
            ser[Series([], dtype=bool)]

            ser[Series([True], dtype=bool)]

        # using column from DataFrame

        ser = string_series
        mask = ser > ser.median()
        omask = mask.astype(object)

        # getitem
        result = ser[omask]
        expected = ser[mask]
        tm.assert_series_equal(result, expected)

        # setitem
        s2 = ser.copy()
        cop = ser.copy()
        cop[omask] = 5
        s2[mask] = 5
        tm.assert_series_equal(cop, s2)

        # nans raise exception
        omask[5:10] = np.nan
        msg = "Cannot mask with non-boolean array containing NA / NaN values"
            ser[omask]
            ser[omask] = 5

        # GH#36210
        dti = date_range("2016-01-01", periods=4, tz="US/Pacific")
        key = np.array([True, True, False, False])

        ser = Series(dti._data)

        res = ser[key]
        assert res._values._ndarray.base is None

        # compare with numeric case for reference
        ser2 = Series(range(4))
        res2 = ser2[key]
        assert res2._values.base is None

        ts = datetime_series
        mask_shifted = ts.shift(1, freq=BDay()) > ts.median()

        msg = (
            r"Unalignable boolean Series provided as indexer \(index of "
            r"the boolean Series and of the indexed object do not match"
        )
            ts[mask_shifted]

            ts.loc[mask_shifted]

        ordered = string_series.sort_values()

        sel = string_series[ordered > 0]
        exp = string_series[string_series > 0]
        tm.assert_series_equal(sel, exp)

        rng = date_range("1/1/2000", "3/1/2000", freq="B")

        mask = np.zeros(len(rng), dtype=bool)
        mask[10:20] = True

        masked = rng[mask]
        expected = rng[10:20]
        assert expected.freq == rng.freq
        tm.assert_index_equal(masked, expected)

        mask[22] = True
        masked = rng[mask]
        assert masked.freq is None


class TestGetitemCallable:
        # GH#12533
        ser = Series(4, index=list("ABCD"))
        result = ser[lambda x: "A"]
        assert result == ser.loc["A"]

        result = ser[lambda x: ["A", "B"]]
        expected = ser.loc[["A", "B"]]
        tm.assert_series_equal(result, expected)

        result = ser[lambda x: [True, False, True, True]]
        expected = ser.iloc[[0, 2, 3]]
        tm.assert_series_equal(result, expected)


    gen = (x > 0 for x in string_series)
    result = string_series[gen]
    result2 = string_series[iter(string_series > 0)]
    expected = string_series[string_series > 0]
    tm.assert_series_equal(result, expected)
    tm.assert_series_equal(result2, expected)


    "series",
    [
        Series([0, 1]),
        Series(date_range("2012-01-01", periods=2)),
        Series(date_range("2012-01-01", periods=2, tz="CET")),
    ],
)
        series[:, None]


    multiindex_year_month_day_dataframe_random_data,
):
    # not implementing this for now
    df = multiindex_year_month_day_dataframe_random_data
    ser = df["A"]

    msg = r"\(2000, slice\(3, 4, None\)\)"
        ser[2000, 3:4]


    rng = list(range(10))
    ser = Series(10, index=rng)
    df = DataFrame(rng, index=rng)
    msg = (
        "Indexing a Series with DataFrame is not supported, "
        "use the appropriate DataFrame column"
    )
        ser[df > 5]


    # https://github.com/pandas-dev/pandas/issues/37427
    # with getitem, when assigning with a Series, it is not first aligned
    ser = Series(range(10))
    idx = np.array([2, 4, 9])
    ser[idx] = Series([10, 11, 12])
    expected = Series([0, 1, 10, 3, 11, 5, 6, 7, 8, 12])
    tm.assert_series_equal(ser, expected)


    # GH#29189 float_index.get_loc(None) should raise KeyError, not TypeError
    ser = Series([2, 5, 6, 8], index=[2.0, 4.0, 4.0, 5.0])
        ser[None]

        ser.index.get_loc(None)

        ser.index._engine.get_loc(None)


    ser = Series(range(5))
    key = (slice(3),)

    result = ser[key]
    expected = ser[key[0]]
    tm.assert_series_equal(result, expected)


    result = datetime_series[datetime_series > 0]
    assert result.name == datetime_series.name

    msg = "Series.__getitem__ treating keys as positions is deprecated"
    with tm.assert_produces_warning(FutureWarning, match=msg):
        result = datetime_series[[0, 2, 4]]
    assert result.name == datetime_series.name

    result = datetime_series[5:10]
    assert result.name == datetime_series.name


    # integer indexes, be careful
    ser = Series(
        np.random.default_rng(2).standard_normal(10), index=list(range(0, 20, 2))
    )
    inds = [0, 2, 5, 7, 8]
    arr_inds = np.array([0, 2, 5, 7, 8])
        ser[inds]

        ser[arr_inds]


    # missing
    d = datetime_series.index[0] - BDay()
    msg = r"Timestamp\('1999-12-31 00:00:00'\)"
        datetime_series[d]


    msg = "Series.__getitem__ treating keys as positions is deprecated"
    with tm.assert_produces_warning(FutureWarning, match=msg):
        slice1 = string_series[[1, 2, 3]]
        slice2 = object_series[[1, 2, 3]]
    assert string_series.index[2] == slice1.index[1]
    assert object_series.index[2] == slice2.index[1]
    assert string_series.iloc[2] == slice1.iloc[1]
    assert object_series.iloc[2] == slice2.iloc[1]


    msg = "Series.__getitem__ treating keys as positions is deprecated"
    with tm.assert_produces_warning(FutureWarning, match=msg):
        value = datetime_series[5]
    assert isinstance(value, np.float64)


    obj = Series(range(5), index=["c", "a", "a", "b", "b"])
    assert is_scalar(obj["c"])
    assert obj["c"] == 0


    ser = Series(range(5), index=["A", "A", "B", "C", "C"], dtype=np.int64)
    expected = Series([3, 4], index=["C", "C"], dtype=np.int64)
    result = ser["C"]
    tm.assert_series_equal(result, expected)


    # GH#31765
    ser = Series(range(5), index=Categorical(["a", "b", "c", "a", "b"]))
    result = ser["a"]
    expected = ser.iloc[[0, 3]]
    tm.assert_series_equal(result, expected)


    ser = Series(1, index=["a", "a", "b", "b", "c"])
    ser[::-1]  # it works!


    # GH 11747
    s = Series(range(5), index=list(index_vals))

    msg = "Series.__getitem__ treating keys as positions is deprecated"
    with tm.assert_produces_warning(FutureWarning, match=msg):
        result = s[3]
    assert result == 3


class TestGetitemDeprecatedIndexers:
        # GH#42825 enforced in 2.0
        ser = Series([1, 2, 3])
            ser[key]

        # GH#42825 enforced in 2.0
        ser = Series([1, 2, 3])
            ser[key] = 1
