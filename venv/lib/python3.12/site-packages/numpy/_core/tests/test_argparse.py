"""
Tests for the private NumPy argument parsing functionality.

match exactly, and could be adjusted):

    def func(arg1, /, arg2, *, arg3):
        i = integer(arg1)  # reproducing the 'i' parsing in Python.
        return None
"""

import threading

    argparse_example_function as func,
)
    threaded_argparse_example_function as thread_func,
)

import numpy as np


    b = threading.Barrier(8)

    def call_thread_func():
        b.wait()
        thread_func(arg1=3, arg2=None)

    tasks = [threading.Thread(target=call_thread_func) for _ in range(8)]
    [t.start() for t in tasks]
    [t.join() for t in tasks]


            match="integer argument expected, got float"):
        func(1.)
        func(2**100)


            match="missing required positional argument 0"):
        func()
            match="missing required positional argument 0"):
        func(arg2=1, arg3=4)
            match=r"missing required argument \'arg2\' \(pos 1\)"):
        func(1, arg3=5)


    # the second argument is positional but can be passed as keyword.
            match="takes from 2 to 3 positional arguments but 4 were given"):
        func(1, 2, 3, 4)


            match=r"given by name \('arg2'\) and position \(position 1\)"):
        func(1, 2, arg2=3)


    # that should normally not be taken due to string interning.
    arg2 = np.str_("arg2")
    missing_arg = np.str_("missing_arg")
    func(1, **{arg2: 3})
            match="got an unexpected keyword argument 'missing_arg'"):
        func(2, **{missing_arg: 3})


    # Not directly related to the standard argument parsing, but we sometimes
    # forward methods to Python: arr.mean() calls np._core._methods._mean()
    # This adds code coverage for this `npy_forward_method`.
    arr = np.arange(3)
    args = range(1000)
        arr.mean(*args)
